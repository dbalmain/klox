#!/usr/bin/env ruby

# Each string: "ClassName : field1Type field1Name, field2Type field2Name, ..."
EXPRESSION_TYPES = [
  "Assign   : Token name, Expr value", # We'll add this later, but good to have a multi-field example
  "Binary   : Expr left, Token operator, Expr right",
  "Call     : Expr callee, Token paren, List<Expr> arguments", # Added from later chapters, but good for testing
  "Get      : Expr objectExpr, Token name", # Added from later chapters
  "Grouping : Expr expression",
  "Literal  : Any? value", # Any? for Kotlin's nullable Object equivalent
  "Logical  : Expr left, Token operator, Expr right", # Added from later chapters
  "Set      : Expr objectExpr, Token name, Expr value", # Added from later chapters
  "Super    : Token keyword, Token method", # Added from later chapters
  "This     : Token keyword", # Added from later chapters
  "Unary    : Token operator, Expr right",
  "Variable : Token name",
]

STATEMENT_TYPES = [
  "Block      : List<Stmt> statements",
  "Expression : Expr expression",
  "Function   : Token name, List<Token> params, List<Stmt> body",
  "If         : Expr condition, Stmt thenBranch, Stmt? elseBranch",
  "Print      : Expr expression",
  "Return     : Token keyword, Expr? value",
  "Var        : Token name, Expr? initializer",
  "While      : Expr condition, Stmt body",
]

# Target Kotlin package and output file
KOTLIN_PACKAGE = "com.craftinginterpreters.klox"
OUTPUT_DIR = "app/src/main/kotlin/com/craftinginterpreters/klox" # Adjust if your path is different
EXPR_OUTPUT_FILE = "#{OUTPUT_DIR}/Expr.kt"
STMT_OUTPUT_FILE = "#{OUTPUT_DIR}/Stmt.kt"

# --- Define AST for Expressions ---
def define_expr_ast(expression_types)
  system("mkdir -p #{OUTPUT_DIR}") unless File.directory?(OUTPUT_DIR)
  File.open(EXPR_OUTPUT_FILE, 'w') do |file|
    file.puts "// Generated by generate_ast.rb - Do not edit manually!"
    file.puts "package #{KOTLIN_PACKAGE}"
    file.puts

    file.puts "sealed class Expr {"
    define_visitor(file, "Expr", expression_types) # Pass base name and suffix
    file.puts "    abstract fun <R> accept(visitor: Visitor<R>): R" # Keep the Visitor inside Expr for now
    file.puts

    expression_types.each do |type_def|
      class_name, fields_str = type_def.split(':').map(&:strip)
      define_type(file, class_name, fields_str, "Expr")
    end
    file.puts "}"
  end
  puts "Generated #{EXPR_OUTPUT_FILE}"
end

# --- Define AST for Statements ---
def define_stmt_ast(statement_types)
  system("mkdir -p #{OUTPUT_DIR}") unless File.directory?(OUTPUT_DIR)
  File.open(STMT_OUTPUT_FILE, 'w') do |file|
    file.puts "// Generated by generate_ast.rb - Do not edit manually!"
    file.puts "package #{KOTLIN_PACKAGE}"
    file.puts

    file.puts "sealed class Stmt {"
    define_visitor(file, "Stmt", statement_types) # Pass base name and suffix
    file.puts "    abstract fun <R> accept(visitor: Visitor<R>): R"
    file.puts

    statement_types.each do |type_def|
      class_name, fields_str = type_def.split(':').map(&:strip)
      # Ensure correct base class for Stmt types
      define_type(file, class_name, fields_str, "Stmt")
    end
    file.puts "}"
  end
  puts "Generated #{STMT_OUTPUT_FILE}"
end

def define_visitor(file, base_name, types)
    file.puts "    interface Visitor<R> {"
    types.each do |type_def|
      class_name = type_def.split(':').first.strip
      file.puts "        fun visit(#{base_name.downcase}: #{class_name}): R"
    end
    file.puts "    }"
    file.puts
end

def define_type(file, class_name, fields_str, base_class_name)
  file.puts "    data class #{class_name}("
  fields = []
  if fields_str && !fields_str.empty?
    fields_str.split(',').each_with_index do |field_def, i|
      type, name = field_def.strip.split(' ')
      fields << "val #{name}: #{type}"
    end
  end
  file.puts "        " + fields.join(",\n        ") unless fields.empty?
  file.puts "    ) : #{base_class_name}() {"
  file.puts "        override fun <R> accept(visitor: Visitor<R>): R = visitor.visit(this)"
  file.puts "    }"
  file.puts
end

# --- Main execution ---
define_expr_ast(EXPRESSION_TYPES)
define_stmt_ast(STATEMENT_TYPES)
