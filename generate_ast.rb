#!/usr/bin/env ruby

# Each string: "ClassName : field1Type field1Name, field2Type field2Name, ..."
EXPRESSION_TYPES = [
  "Assign   : Token name, Expr value", # We'll add this later, but good to have a multi-field example
  "Binary   : Expr left, Token operator, Expr right",
  "Call     : Expr callee, Token paren, List<Expr> arguments", # Added from later chapters, but good for testing
  "Get      : Expr object, Token name", # Added from later chapters
  "Grouping : Expr expression",
  "Literal  : Any? value", # Any? for Kotlin's nullable Object equivalent
  "Logical  : Expr left, Token operator, Expr right", # Added from later chapters
  "Set      : Expr object, Token name, Expr value", # Added from later chapters
  "Super    : Token keyword, Token method", # Added from later chapters
  "This     : Token keyword", # Added from later chapters
  "Unary    : Token operator, Expr right",
  "Variable : Token name"
]

# Target Kotlin package and output file
KOTLIN_PACKAGE = "com.craftinginterpreters.klox"
OUTPUT_DIR = "app/src/main/kotlin/com/craftinginterpreters/klox" # Adjust if your path is different
OUTPUT_FILE = "#{OUTPUT_DIR}/Expr.kt"

def define_ast(expression_types)
  # Ensure output directory exists
  system("mkdir -p #{OUTPUT_DIR}") unless File.directory?(OUTPUT_DIR)

  File.open(OUTPUT_FILE, 'w') do |file|
    file.puts "// Generated by generate_ast.rb - Do not edit manually!"
    file.puts "package #{KOTLIN_PACKAGE}"
    file.puts
    # Add imports if necessary, List and Token will be needed
    file.puts "import #{KOTLIN_PACKAGE}.Token"
    file.puts # Potentially java.util.List if not using Kotlin's List directly for arguments
    file.puts

    file.puts "sealed class Expr {"
    define_visitor(file, expression_types)
    file.puts "    abstract fun <R> accept(visitor: Visitor<R>): R"
    file.puts

    expression_types.each do |type_def|
      class_name, fields_str = type_def.split(':').map(&:strip)
      define_type(file, class_name, fields_str)
    end

    file.puts "}" # End of sealed class Expr
  end

  puts "Generated #{OUTPUT_FILE}"
end

def define_visitor(file, expression_types)
  file.puts "    interface Visitor<R> {"
  expression_types.each do |type_def|
    class_name = type_def.split(':').first.strip
    file.puts "        fun visit#{class_name}Expr(expr: #{class_name}): R"
  end
  file.puts "    }"
  file.puts
end

def define_type(file, class_name, fields_str)
  file.puts "    data class #{class_name}("
  fields = []
  if fields_str && !fields_str.empty?
    fields_str.split(',').each_with_index do |field_def, i|
      type, name = field_def.strip.split(' ')
      # Convert common Java types to Kotlin; this can be expanded
      kotlin_type = type.gsub("List<Expr>", "List<Expr>") # Example, might need more robust mapping
      kotlin_type = kotlin_type.gsub("Any?", "Any?") # Already Kotlin-idiomatic
      fields << "val #{name}: #{kotlin_type}"
    end
  end
  file.puts "        " + fields.join(",\n        ") unless fields.empty?
  file.puts "    ) : Expr() {"
  file.puts "        override fun <R> accept(visitor: Visitor<R>): R {"
  file.puts "            return visitor.visit#{class_name}Expr(this)"
  file.puts "        }"
  file.puts "    }"
  file.puts
end

# --- Main execution ---
define_ast(EXPRESSION_TYPES)
